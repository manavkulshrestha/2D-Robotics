```int inv_arm_kinematics(roger, limb, x, y, errors)
Robot * roger;
int limb;
double x, y;
double errors[2][2];
{
  double wTb[4][4], bTw[4][4], ref_b[4], ref_w[4];

  double r2, c2, s2_plus, s2_minus, theta2_plus, theta2_minus;
  double k1, k2_plus, k2_minus, alpha_plus, alpha_minus;
  double theta1_plus, theta1_minus;
  double theta1_plus_dist, theta2_plus_dist, theta1_minus_dist, theta2_minus_dist, plus_dist, minus_dist;

  // input (x,y) is in world frame coordinates - map it into the base frame


  construct_wTb(roger->base_position, wTb);
  HT_invert(wTb,bTw);

  ref_w[0] = x;
  ref_w[1] = y;
  ref_w[2] = 0.0;
  ref_w[3] = 1.0;

  matrix_mult(4, 4, bTw, 1, ref_w, ref_b);
  if (limb==LEFT) ref_b[Y] -= ARM_OFFSET;
  else ref_b[Y] += ARM_OFFSET;

  r2 = (ref_b[X] * ref_b[X]) + (ref_b[Y] * ref_b[Y]);
  c2 = (r2 - (L_ARM1*L_ARM1) - (L_ARM2 * L_ARM2))/(2*L_ARM1*L_ARM2);

  //printf("%f\n",c2); 
  if(c2 < -1 || c2 > 1){
    return FALSE;
  }else{
    s2_plus = sqrt(1 - (c2*c2));
    s2_minus = -1 * s2_plus;

    theta2_plus = atan2(s2_plus,c2);
    theta2_minus = atan2(s2_minus,c2);

    k1 = L_ARM1 + (L_ARM2*c2);

    k2_plus = L_ARM2*s2_plus;
    k2_minus = L_ARM2*s2_minus;

    alpha_plus = atan2(k2_plus,k1);
    alpha_minus = atan2(k2_minus, k1);

    theta1_plus = atan2(ref_b[Y], ref_b[X]) - alpha_plus;
    theta1_minus = atan2(ref_b[Y], ref_b[X]) - alpha_minus;

    theta1_plus_dist = theta1_plus - roger->arm_theta[limb][0];
    theta1_minus_dist = theta1_minus - roger->arm_theta[limb][0];

    theta2_plus_dist = theta2_plus - roger->arm_theta[limb][1];
    theta2_minus_dist = theta2_minus - roger->arm_theta[limb][1];

    plus_dist = sqrt((theta1_plus_dist*theta1_plus_dist) + (theta2_plus_dist * theta2_plus_dist));
    minus_dist = sqrt((theta1_minus_dist*theta1_minus_dist) + (theta2_minus_dist * theta2_minus_dist));

    if(plus_dist > minus_dist){
      //roger->arm_setpoint[limb][0] = theta1_minus;
      //roger->arm_setpoint[limb][1] = theta2_minus;
      errors[limb][0] =theta1_minus;
      errors[limb][1] =theta2_minus;
    }else{
      // roger->arm_setpoint[limb][0] = theta1_plus;
      // roger->arm_setpoint[limb][1] = theta2_plus;
      errors[limb][0] =theta1_plus;
      errors[limb][1] =theta2_plus;
    }
    return TRUE;
  }
  // printf("x = %6.4lf  y = %6.4lf OUT OF REACH\n", ref_b[X], ref_b[Y]);
}
```